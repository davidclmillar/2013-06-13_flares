# compare the results of the spectrum fitting. Use the results generated by the spectrum fitting script.
import numpy as np
import kappa_fitting as k
import pickle
import concurrent.futures
from tqdm import tqdm
from scipy import stats

import warnings
warnings.filterwarnings("ignore")

sg = 0.999 # chosen significance level

n = 111 # number of time instances used for each timeseries
dt = 30.7 # cadence (s)

# the frequency values for the spectra
freqs = np.fft.fftfreq(n,dt)
freqs = freqs[1:int(n/2)]

# the m factor (significance level)
m = k.siglvl(sg,len(freqs))

result_path='fitting_results.p'
p = pickle.load(open(result_path,'rb')) # load in the results of the fitting

total = len(p[0])
print('starting: ',result_path)
# get no cores
no_cores = os.cpu_count() - 1
print('no cores : {}'.format(no_cores))
# total no pixels
print('total pixels : {}'.format(total))

print('pixels per core = %.2f'%(total/no_cores)) 
print('So we need %d cores with %d pixels and %d cores with %d pixels.\n ' \
      %(total % no_cores, np.ceil(total/no_cores),no_cores - (total % no_cores), np.floor(total/no_cores)))

# this list will have all of the minimum values that each core will begin at, once the array is flattened 
mins = np.zeros(shape=no_cores+1)
i = 0
for a in range(1,no_cores):
    if i < (total % no_cores):
        mins[a] = mins[a-1] + np.ceil(total/no_cores)
        i+=1
    else:
        mins[a] = mins[a-1] + np.floor(total/no_cores)
mins[-1] = total
mins = mins.astype(int)

# function used to compare the results at each pixel
def compare(results, freqs = freqs, signif = sg):
    popt1 = results[0]
    popt2 = results[1]
    poptk = results[2]

    WRSes = results[3]

    # see if any F-tests need to be performed
    WRS_list = WRSes
   # check if all fits failed
    if (np.mean(WRSes)==1e10):   # no fits successful
        pref = 0   

    # if model1 is best
    elif (WRS_list[0]<=WRS_list[1]) & (WRS_list[0]<=WRS_list[2]): # 
        pref = 1

    # if model 2 seems best, do an f test and check height of bump if it passes
    elif np.argmin(WRS_list)==1:
        F_stat = ((WRS_list[0] - WRS_list[1])/(3))/((WRS_list[1])/(len(freqs) - 6))
        p_value = 1 - stats.f.cdf(F_stat, 3, len(freqs) - 6)
        if p_value < (1-signif):
            # test height of bump
            params = popt2

            just_line = k.model2(freqs, *(params*[1,1,0,1,1,1]))
            signify    = m*just_line
            fit = k.model2(freqs, *params)
            index = np.argmax(fit/just_line)
            #  if it failed the f test, assign m3 or m1 depending on which has the best WRS 
            if (fit[index] > signify[index]) & (params[3] > -6.1) & (params[3] < -3.91):
                pref = 2

            elif WRS_list[2] < WRS_list[0]:
                pref = 3

            else:
                pref = 1

        else:
            pref = 1
    # if m3 looks like the best, do an f-test
    else:
        F_stat = ((WRS_list[0] - WRS_list[2])/(3))/((WRS_list[2])/(len(freqs) - 6))
        p_value = 1 - stats.f.cdf(F_stat, 3, len(freqs) - 6)
        if p_value < (1-signif):
            pref = 3
        else:
            pref = 1

    return pref


def function(mini,maxi):
    res = []
    for i in range(maxi-mini):
        inputs = p[1][i+mini]
        res.append(compare(inputs))
    return res

# parallel processing
with concurrent.futures.ProcessPoolExecutor(max_workers=no_cores) as executor:
    futures=[executor.submit(function, mins[j], mins[j+1]) for j in range(len(mins)-1)]
    for f in tqdm(concurrent.futures.as_completed(futures), total=len(futures)):
        pass #This gets a progress bar
      
# pull the results together and save
# ---------------------------------
results=[res.result() for res in futures]
bigr = []
[bigr.extend(r) for r in results]
save_this = [p[0],bigr]
pickle.dump(save_this, open('compare.p',"wb"))
